// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: organization.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBooking = `-- name: CreateBooking :one
INSERT INTO bookings (payment_id, service_id, slot_id, booking_date, status) VALUES ($1,$2,$3,$4,$5)
RETURNING booking_id, payment_id, booking_date, status, created_at, service_id, slot_id
`

type CreateBookingParams struct {
	PaymentID   string      `json:"payment_id"`
	ServiceID   *string     `json:"service_id"`
	SlotID      *string     `json:"slot_id"`
	BookingDate pgtype.Date `json:"booking_date"`
	Status      string      `json:"status"`
}

func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) (Booking, error) {
	row := q.db.QueryRow(ctx, createBooking,
		arg.PaymentID,
		arg.ServiceID,
		arg.SlotID,
		arg.BookingDate,
		arg.Status,
	)
	var i Booking
	err := row.Scan(
		&i.BookingID,
		&i.PaymentID,
		&i.BookingDate,
		&i.Status,
		&i.CreatedAt,
		&i.ServiceID,
		&i.SlotID,
	)
	return i, err
}

const createOrganization = `-- name: CreateOrganization :one
INSERT INTO organizations (
     name, location, start_time, end_time, email
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING organization_id, name, location, start_time, end_time, email, image_url
`

type CreateOrganizationParams struct {
	Name      string      `json:"name"`
	Location  *string     `json:"location"`
	StartTime pgtype.Time `json:"start_time"`
	EndTime   pgtype.Time `json:"end_time"`
	Email     *string     `json:"email"`
}

func (q *Queries) CreateOrganization(ctx context.Context, arg CreateOrganizationParams) (Organization, error) {
	row := q.db.QueryRow(ctx, createOrganization,
		arg.Name,
		arg.Location,
		arg.StartTime,
		arg.EndTime,
		arg.Email,
	)
	var i Organization
	err := row.Scan(
		&i.OrganizationID,
		&i.Name,
		&i.Location,
		&i.StartTime,
		&i.EndTime,
		&i.Email,
		&i.ImageUrl,
	)
	return i, err
}

const createPayment = `-- name: CreatePayment :one



INSERT INTO payments (
    cus_name,
    cus_email,
    phone_number,
    date,
    service_id,
    slot_id,
    amount,
    status,
    transaction_ref
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING payment_id, cus_name, cus_email, phone_number, date, service_id, slot_id, amount, status, transaction_ref, created_at
`

type CreatePaymentParams struct {
	CusName        string      `json:"cus_name"`
	CusEmail       string      `json:"cus_email"`
	PhoneNumber    string      `json:"phone_number"`
	Date           pgtype.Date `json:"date"`
	ServiceID      string      `json:"service_id"`
	SlotID         string      `json:"slot_id"`
	Amount         float64     `json:"amount"`
	Status         string      `json:"status"`
	TransactionRef string      `json:"transaction_ref"`
}

// -- Search services.name
// SELECT 'services' AS source, service_id, service_name AS value
// FROM services
// WHERE to_tsvector(service_name) @@ websearch_to_tsquery($1)
// UNION ALL
// -- Search organisations.email
// SELECT 'organizations' AS source, organization_id, name AS value
// FROM organizations
// WHERE to_tsvector(name) @@ websearch_to_tsquery($1);
func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.CusName,
		arg.CusEmail,
		arg.PhoneNumber,
		arg.Date,
		arg.ServiceID,
		arg.SlotID,
		arg.Amount,
		arg.Status,
		arg.TransactionRef,
	)
	var i Payment
	err := row.Scan(
		&i.PaymentID,
		&i.CusName,
		&i.CusEmail,
		&i.PhoneNumber,
		&i.Date,
		&i.ServiceID,
		&i.SlotID,
		&i.Amount,
		&i.Status,
		&i.TransactionRef,
		&i.CreatedAt,
	)
	return i, err
}

const createService = `-- name: CreateService :one
INSERT INTO services (
    organization_id, service_name, service_description, duration
) VALUES (
    $1, $2, $3, $4
)
RETURNING service_id
`

type CreateServiceParams struct {
	OrganizationID     string `json:"organization_id"`
	ServiceName        string `json:"service_name"`
	ServiceDescription string `json:"service_description"`
	Duration           int32  `json:"duration"`
}

func (q *Queries) CreateService(ctx context.Context, arg CreateServiceParams) (string, error) {
	row := q.db.QueryRow(ctx, createService,
		arg.OrganizationID,
		arg.ServiceName,
		arg.ServiceDescription,
		arg.Duration,
	)
	var service_id string
	err := row.Scan(&service_id)
	return service_id, err
}

const getBookingsInDateRange = `-- name: GetBookingsInDateRange :many

SELECT slot_id, booking_date
FROM bookings
WHERE service_id = $1
  AND booking_date BETWEEN $2 AND $3
`

type GetBookingsInDateRangeParams struct {
	ServiceID     *string     `json:"service_id"`
	BookingDate   pgtype.Date `json:"booking_date"`
	BookingDate_2 pgtype.Date `json:"booking_date_2"`
}

type GetBookingsInDateRangeRow struct {
	SlotID      *string     `json:"slot_id"`
	BookingDate pgtype.Date `json:"booking_date"`
}

// -- name: GetPaymentStatusByID :one
// SELECT status
// FROM payments
// WHERE payment_id = $1;
func (q *Queries) GetBookingsInDateRange(ctx context.Context, arg GetBookingsInDateRangeParams) ([]GetBookingsInDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getBookingsInDateRange, arg.ServiceID, arg.BookingDate, arg.BookingDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBookingsInDateRangeRow{}
	for rows.Next() {
		var i GetBookingsInDateRangeRow
		if err := rows.Scan(&i.SlotID, &i.BookingDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationBookings = `-- name: GetOrganizationBookings :many
SELECT 
  b.booking_id, 
  b.booking_date, 
  p.cus_name, 
  p.cus_email, 
  p.phone_number,
  s.service_name, 
  st.start_time
FROM bookings b 
LEFT JOIN payments p 
  ON b.payment_id = p.payment_id 
LEFT JOIN services s 
  ON s.service_id = p.service_id
LEFT JOIN service_slot_templates st 
  ON st.id = p.slot_id
`

type GetOrganizationBookingsRow struct {
	BookingID   string      `json:"booking_id"`
	BookingDate pgtype.Date `json:"booking_date"`
	CusName     string      `json:"cus_name"`
	CusEmail    string      `json:"cus_email"`
	PhoneNumber string      `json:"phone_number"`
	ServiceName *string     `json:"service_name"`
	StartTime   pgtype.Time `json:"start_time"`
}

func (q *Queries) GetOrganizationBookings(ctx context.Context) ([]GetOrganizationBookingsRow, error) {
	rows, err := q.db.Query(ctx, getOrganizationBookings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrganizationBookingsRow{}
	for rows.Next() {
		var i GetOrganizationBookingsRow
		if err := rows.Scan(
			&i.BookingID,
			&i.BookingDate,
			&i.CusName,
			&i.CusEmail,
			&i.PhoneNumber,
			&i.ServiceName,
			&i.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationData = `-- name: GetOrganizationData :one
SELECT organization_id, name, location, start_time, end_time, email, image_url FROM organizations
WHERE email = $1
`

func (q *Queries) GetOrganizationData(ctx context.Context, email *string) (Organization, error) {
	row := q.db.QueryRow(ctx, getOrganizationData, email)
	var i Organization
	err := row.Scan(
		&i.OrganizationID,
		&i.Name,
		&i.Location,
		&i.StartTime,
		&i.EndTime,
		&i.Email,
		&i.ImageUrl,
	)
	return i, err
}

const getOrganizations = `-- name: GetOrganizations :many
SELECT organization_id, name, location, COALESCE(image_url, '') AS image_url, start_time, end_time FROM organizations
WHERE name <> ''
`

type GetOrganizationsRow struct {
	OrganizationID string      `json:"organization_id"`
	Name           string      `json:"name"`
	Location       *string     `json:"location"`
	ImageUrl       string      `json:"image_url"`
	StartTime      pgtype.Time `json:"start_time"`
	EndTime        pgtype.Time `json:"end_time"`
}

func (q *Queries) GetOrganizations(ctx context.Context) ([]GetOrganizationsRow, error) {
	rows, err := q.db.Query(ctx, getOrganizations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrganizationsRow{}
	for rows.Next() {
		var i GetOrganizationsRow
		if err := rows.Scan(
			&i.OrganizationID,
			&i.Name,
			&i.Location,
			&i.ImageUrl,
			&i.StartTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentByID = `-- name: GetPaymentByID :one
SELECT payment_id, cus_name, cus_email, phone_number, date, service_id, slot_id, amount, status, transaction_ref, created_at 
FROM payments 
WHERE payment_id = $1
`

func (q *Queries) GetPaymentByID(ctx context.Context, paymentID string) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByID, paymentID)
	var i Payment
	err := row.Scan(
		&i.PaymentID,
		&i.CusName,
		&i.CusEmail,
		&i.PhoneNumber,
		&i.Date,
		&i.ServiceID,
		&i.SlotID,
		&i.Amount,
		&i.Status,
		&i.TransactionRef,
		&i.CreatedAt,
	)
	return i, err
}

const getSearchResults = `-- name: GetSearchResults :many

SELECT service_id, organization_id, service_name, service_description, duration FROM services WHERE service_name ILIKE '%' || $1 || '%'
`

// -- name: UpdatePaymentStatus :exec
// UPDATE payments
// SET
//
//	status = $2,
//	transaction_ref = $3
//
// WHERE payment_id = $1;
func (q *Queries) GetSearchResults(ctx context.Context, dollar_1 string) ([]Service, error) {
	rows, err := q.db.Query(ctx, getSearchResults, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Service{}
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ServiceID,
			&i.OrganizationID,
			&i.ServiceName,
			&i.ServiceDescription,
			&i.Duration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceSlots = `-- name: GetServiceSlots :many
SELECT 
    id,
    service_id,
    start_time,
    end_time
FROM service_slot_templates
WHERE service_id = $1
ORDER BY start_time
`

func (q *Queries) GetServiceSlots(ctx context.Context, serviceID string) ([]ServiceSlotTemplate, error) {
	rows, err := q.db.Query(ctx, getServiceSlots, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ServiceSlotTemplate{}
	for rows.Next() {
		var i ServiceSlotTemplate
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.StartTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceWithOrgTimes = `-- name: GetServiceWithOrgTimes :one
SELECT s.service_id, s.duration, o.start_time, o.end_time
FROM services s
JOIN organizations o ON s.organization_id = o.organization_id
WHERE s.service_id = $1
`

type GetServiceWithOrgTimesRow struct {
	ServiceID string      `json:"service_id"`
	Duration  int32       `json:"duration"`
	StartTime pgtype.Time `json:"start_time"`
	EndTime   pgtype.Time `json:"end_time"`
}

func (q *Queries) GetServiceWithOrgTimes(ctx context.Context, serviceID string) (GetServiceWithOrgTimesRow, error) {
	row := q.db.QueryRow(ctx, getServiceWithOrgTimes, serviceID)
	var i GetServiceWithOrgTimesRow
	err := row.Scan(
		&i.ServiceID,
		&i.Duration,
		&i.StartTime,
		&i.EndTime,
	)
	return i, err
}

const getServicesByOrganization = `-- name: GetServicesByOrganization :many
SELECT service_id, organization_id, service_name, service_description, duration FROM services
WHERE organization_id = $1
`

func (q *Queries) GetServicesByOrganization(ctx context.Context, organizationID string) ([]Service, error) {
	rows, err := q.db.Query(ctx, getServicesByOrganization, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Service{}
	for rows.Next() {
		var i Service
		if err := rows.Scan(
			&i.ServiceID,
			&i.OrganizationID,
			&i.ServiceName,
			&i.ServiceDescription,
			&i.Duration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertSlotTemplate = `-- name: InsertSlotTemplate :exec
INSERT INTO service_slot_templates (
    service_id, start_time, end_time
) VALUES ($1, $2, $3)
ON CONFLICT (service_id, start_time) DO NOTHING
`

type InsertSlotTemplateParams struct {
	ServiceID string      `json:"service_id"`
	StartTime pgtype.Time `json:"start_time"`
	EndTime   pgtype.Time `json:"end_time"`
}

func (q *Queries) InsertSlotTemplate(ctx context.Context, arg InsertSlotTemplateParams) error {
	_, err := q.db.Exec(ctx, insertSlotTemplate, arg.ServiceID, arg.StartTime, arg.EndTime)
	return err
}

const updateOrganizationData = `-- name: UpdateOrganizationData :one
UPDATE organizations
SET name = $1, location = $2, start_time = $3, end_time = $4, image_url = $5
WHERE email = $6
RETURNING organization_id, name, location, start_time, end_time, email, image_url
`

type UpdateOrganizationDataParams struct {
	Name      string      `json:"name"`
	Location  *string     `json:"location"`
	StartTime pgtype.Time `json:"start_time"`
	EndTime   pgtype.Time `json:"end_time"`
	ImageUrl  string      `json:"image_url"`
	Email     *string     `json:"email"`
}

func (q *Queries) UpdateOrganizationData(ctx context.Context, arg UpdateOrganizationDataParams) (Organization, error) {
	row := q.db.QueryRow(ctx, updateOrganizationData,
		arg.Name,
		arg.Location,
		arg.StartTime,
		arg.EndTime,
		arg.ImageUrl,
		arg.Email,
	)
	var i Organization
	err := row.Scan(
		&i.OrganizationID,
		&i.Name,
		&i.Location,
		&i.StartTime,
		&i.EndTime,
		&i.Email,
		&i.ImageUrl,
	)
	return i, err
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :exec
UPDATE payments
SET status = $1
WHERE transaction_ref = $2
`

type UpdatePaymentStatusParams struct {
	Status         string `json:"status"`
	TransactionRef string `json:"transaction_ref"`
}

func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) error {
	_, err := q.db.Exec(ctx, updatePaymentStatus, arg.Status, arg.TransactionRef)
	return err
}
